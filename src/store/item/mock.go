// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package item

import (
	"git.d.foundation/datcom/backend/models"
	"git.d.foundation/datcom/backend/src/store/menu"
	"sync"
)

var (
	lockServiceMockAddAnItem      sync.RWMutex
	lockServiceMockCheckItemExist sync.RWMutex
)

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
//     func TestSomethingThatUsesService(t *testing.T) {
//
//         // make and configure a mocked Service
//         mockedService := &ServiceMock{
//             AddAnItemFunc: func(i *Item) (*models.Item, error) {
// 	               panic("mock out the AddAnItem method")
//             },
//             CheckItemExistFunc: func(i *Item, m *menu.Menu) (bool, error) {
// 	               panic("mock out the CheckItemExist method")
//             },
//         }
//
//         // use mockedService in code that requires Service
//         // and then make assertions.
//
//     }
type ServiceMock struct {
	// AddAnItemFunc mocks the AddAnItem method.
	AddAnItemFunc func(i *Item) (*models.Item, error)

	// CheckItemExistFunc mocks the CheckItemExist method.
	CheckItemExistFunc func(i *Item, m *menu.Menu) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddAnItem holds details about calls to the AddAnItem method.
		AddAnItem []struct {
			// I is the i argument value.
			I *Item
		}
		// CheckItemExist holds details about calls to the CheckItemExist method.
		CheckItemExist []struct {
			// I is the i argument value.
			I *Item
			// M is the m argument value.
			M *menu.Menu
		}
	}
}

// AddAnItem calls AddAnItemFunc.
func (mock *ServiceMock) AddAnItem(i *Item) (*models.Item, error) {
	if mock.AddAnItemFunc == nil {
		panic("ServiceMock.AddAnItemFunc: method is nil but Service.AddAnItem was just called")
	}
	callInfo := struct {
		I *Item
	}{
		I: i,
	}
	lockServiceMockAddAnItem.Lock()
	mock.calls.AddAnItem = append(mock.calls.AddAnItem, callInfo)
	lockServiceMockAddAnItem.Unlock()
	return mock.AddAnItemFunc(i)
}

// AddAnItemCalls gets all the calls that were made to AddAnItem.
// Check the length with:
//     len(mockedService.AddAnItemCalls())
func (mock *ServiceMock) AddAnItemCalls() []struct {
	I *Item
} {
	var calls []struct {
		I *Item
	}
	lockServiceMockAddAnItem.RLock()
	calls = mock.calls.AddAnItem
	lockServiceMockAddAnItem.RUnlock()
	return calls
}

// CheckItemExist calls CheckItemExistFunc.
func (mock *ServiceMock) CheckItemExist(i *Item, m *menu.Menu) (bool, error) {
	if mock.CheckItemExistFunc == nil {
		panic("ServiceMock.CheckItemExistFunc: method is nil but Service.CheckItemExist was just called")
	}
	callInfo := struct {
		I *Item
		M *menu.Menu
	}{
		I: i,
		M: m,
	}
	lockServiceMockCheckItemExist.Lock()
	mock.calls.CheckItemExist = append(mock.calls.CheckItemExist, callInfo)
	lockServiceMockCheckItemExist.Unlock()
	return mock.CheckItemExistFunc(i, m)
}

// CheckItemExistCalls gets all the calls that were made to CheckItemExist.
// Check the length with:
//     len(mockedService.CheckItemExistCalls())
func (mock *ServiceMock) CheckItemExistCalls() []struct {
	I *Item
	M *menu.Menu
} {
	var calls []struct {
		I *Item
		M *menu.Menu
	}
	lockServiceMockCheckItemExist.RLock()
	calls = mock.calls.CheckItemExist
	lockServiceMockCheckItemExist.RUnlock()
	return calls
}
